{"version":3,"sources":["components/NoWalletDetected.js","components/NetworkErrorMessage.js","components/ConnectWallet.js","components/Loading.js","components/Transfer.js","components/TransactionErrorMessage.js","components/WaitingForTransactionMessage.js","components/NoTokensMessage.js","components/Dapp.js","index.js"],"names":["NoWalletDetected","className","href","target","rel","NetworkErrorMessage","message","dismiss","role","type","data-dismiss","aria-label","onClick","aria-hidden","ConnectWallet","connectWallet","networkError","Loading","style","position","zIndex","top","left","width","height","background","marginLeft","marginTop","textAlign","Transfer","transferTokens","tokenSymbol","onSubmit","event","preventDefault","formData","FormData","to","get","amount","step","name","placeholder","required","value","TransactionErrorMessage","substring","WaitingForTransactionMessage","txHash","NoTokensMessage","selectedAddress","Dapp","props","initialState","tokenData","undefined","balance","txBeingSent","transactionError","state","window","ethereum","this","symbol","toString","_getRpcErrorMessage","_dismissTransactionError","eq","gt","_transferTokens","_connectWallet","_dismissNetworkError","_stopPollingData","enable","_checkNetwork","_initialize","on","newAddress","_resetState","userAddress","setState","_intializeEthers","_getTokenData","_startPollingData","_provider","ethers","providers","Web3Provider","_token","Contract","contractAddress","Token","TokenArtifact","abi","getSigner","_pollDataInterval","setInterval","_updateBalance","clearInterval","balanceOf","transfer","tx","hash","wait","status","Error","code","console","error","data","networkVersion","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4f594e6c.chunk.js","sourcesContent":["import React from \"react\";\n\nexport function NoWalletDetected() {\n  return (\n    <div className=\"container\">\n      <div className=\"row justify-content-md-center\">\n        <div className=\"col-6 p-4 text-center\">\n          <p>\n            No Ethereum wallet was detected. <br />\n            Please install{\" \"}\n            <a\n              href=\"http://metamask.io\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              MetaMask\n            </a>\n            .\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function NetworkErrorMessage({ message, dismiss }) {\n  return (\n    <div className=\"alert alert-danger\" role=\"alert\">\n      {message}\n      <button\n        type=\"button\"\n        className=\"close\"\n        data-dismiss=\"alert\"\n        aria-label=\"Close\"\n        onClick={dismiss}\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  );\n}\n","import React from \"react\";\n\nimport { NetworkErrorMessage } from \"./NetworkErrorMessage\";\n\nexport function ConnectWallet({ connectWallet, networkError, dismiss }) {\n  return (\n    <div className=\"container\">\n      <div className=\"row justify-content-md-center\">\n        <div className=\"col-12 text-center\">\n          {/* Metamask network should be set to Localhost:8545. */}\n          {networkError && (\n            <NetworkErrorMessage \n              message={networkError} \n              dismiss={dismiss} \n            />\n          )}\n        </div>\n        <div className=\"col-6 p-4 text-center\">\n          <p>Please connect to your wallet.</p>\n          <button\n            className=\"btn btn-warning\"\n            type=\"button\"\n            onClick={connectWallet}\n          >\n            Connect Wallet\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function Loading() {\n  return (\n    <div\n      style={{\n        position: \"fixed\",\n        zIndex: 2,\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n        background: \"rgba(255, 255, 255, 0.5)\",\n      }}\n    >\n      <div\n        style={{\n          position: \"absolute\",\n          zIndex: 3,\n          top: \"50%\",\n          left: \"50%\",\n          width: \"100px\",\n          height: \"50px\",\n          marginLeft: \"-50px\",\n          marginTop: \" -25px\",\n          textAlign: \"center\",\n        }}\n      >\n        <div className=\"spinner-border\" role=\"status\">\n          <span className=\"sr-only\">Loading...</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function Transfer({ transferTokens, tokenSymbol }) {\n  return (\n    <div>\n      <h4>Transfer</h4>\n      <form\n        onSubmit={(event) => {\n          // This function just calls the transferTokens callback with the\n          // form's data.\n          event.preventDefault();\n\n          const formData = new FormData(event.target);\n          const to = formData.get(\"to\");\n          const amount = formData.get(\"amount\");\n\n          if (to && amount) {\n            transferTokens(to, amount);\n          }\n        }}\n      >\n        <div className=\"form-group\">\n          <label>Amount of {tokenSymbol}</label>\n          <input\n            className=\"form-control\"\n            type=\"number\"\n            step=\"1\"\n            name=\"amount\"\n            placeholder=\"1\"\n            required\n          />\n        </div>\n        <div className=\"form-group\">\n          <label>Recipient address</label>\n          <input className=\"form-control\" type=\"text\" name=\"to\" required />\n        </div>\n        <div className=\"form-group\">\n          <input className=\"btn btn-primary\" type=\"submit\" value=\"Transfer\" />\n        </div>\n      </form>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function TransactionErrorMessage({ message, dismiss }) {\n  return (\n    <div className=\"alert alert-danger\" role=\"alert\">\n      Error sending transaction: {message.substring(0, 100)}\n      <button\n        type=\"button\"\n        className=\"close\"\n        data-dismiss=\"alert\"\n        aria-label=\"Close\"\n        onClick={dismiss}\n      >\n        <span aria-hidden=\"true\">&times;</span>\n      </button>\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function WaitingForTransactionMessage({ txHash }) {\n  return (\n    <div className=\"alert alert-info\" role=\"alert\">\n      Waiting for transaction <strong>{txHash}</strong> to be mined\n    </div>\n  );\n}\n","import React from \"react\";\n\nexport function NoTokensMessage({ selectedAddress }) {\n  return (\n    <>\n      <p>You don't have tokens to transfer</p>\n    </>\n  );\n}\n","import React from \"react\";\n\n// We'll use ethers to interact with the Ethereum network and our contract\nimport { ethers } from \"ethers\";\n\n// We import the contract's artifacts and address here, as we are going to be\n// using them with ethers\nimport TokenArtifact from \"../contracts/Token.json\";\nimport contractAddress from \"../contracts/contract-address.json\";\n\n// All the logic of this dapp is contained in the Dapp component.\n// These other components are just presentational ones: they don't have any\n// logic. They just render HTML.\nimport { NoWalletDetected } from \"./NoWalletDetected\";\nimport { ConnectWallet } from \"./ConnectWallet\";\nimport { Loading } from \"./Loading\";\nimport { Transfer } from \"./Transfer\";\nimport { TransactionErrorMessage } from \"./TransactionErrorMessage\";\nimport { WaitingForTransactionMessage } from \"./WaitingForTransactionMessage\";\nimport { NoTokensMessage } from \"./NoTokensMessage\";\n\n// This is the Hardhat Network id, you might change it in the hardhat.config.js\n// Here's a list of network ids https://docs.metamask.io/guide/ethereum-provider.html#properties\n// to use when deploying to other networks.\nconst HARDHAT_NETWORK_ID = '1074';\n\n// This is an error code that indicates that the user canceled a transaction\nconst ERROR_CODE_TX_REJECTED_BY_USER = 4001;\n\n// This component is in charge of doing these things:\n//   1. It connects to the user's wallet\n//   2. Initializes ethers and the Token contract\n//   3. Polls the user balance to keep it updated.\n//   4. Transfers tokens by sending transactions\n//   5. Renders the whole application\n//\n// Note that (3) and (4) are specific of this sample application, but they show\n// you how to keep your Dapp and contract's state in sync,  and how to send a\n// transaction.\nexport class Dapp extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // We store multiple things in Dapp's state.\n    // You don't need to follow this pattern, but it's an useful example.\n    this.initialState = {\n      // The info of the token (i.e. It's Name and symbol)\n      tokenData: undefined,\n      // The user's address and balance\n      selectedAddress: undefined,\n      balance: undefined,\n      // The ID about transactions being sent, and any possible error with them\n      txBeingSent: undefined,\n      transactionError: undefined,\n      networkError: undefined,\n    };\n\n    this.state = this.initialState;\n  }\n\n  render() {\n    // Ethereum wallets inject the window.ethereum object. If it hasn't been\n    // injected, we instruct the user to install MetaMask.\n    if (window.ethereum === undefined) {\n      return <NoWalletDetected />;\n    }\n\n    // The next thing we need to do, is to ask the user to connect their wallet.\n    // When the wallet gets connected, we are going to save the users's address\n    // in the component's state. So, if it hasn't been saved yet, we have\n    // to show the ConnectWallet component.\n    //\n    // Note that we pass it a callback that is going to be called when the user\n    // clicks a button. This callback just calls the _connectWallet method.\n    if (!this.state.selectedAddress) {\n      return (\n        <ConnectWallet \n          connectWallet={() => this._connectWallet()} \n          networkError={this.state.networkError}\n          dismiss={() => this._dismissNetworkError()}\n        />\n      );\n    }\n\n    // If the token data or the user's balance hasn't loaded yet, we show\n    // a loading component.\n    if (!this.state.tokenData || !this.state.balance) {\n      return <Loading />;\n    }\n\n    // If everything is loaded, we render the application.\n    return (\n      <div className=\"container p-4\">\n        <div className=\"row\">\n          <div className=\"col-12\">\n            <h1>\n              {this.state.tokenData.name} ({this.state.tokenData.symbol})\n            </h1>\n            <p>\n              Welcome <b>{this.state.selectedAddress}</b>, you have{\" \"}\n              <b>\n                {this.state.balance.toString()} {this.state.tokenData.symbol}\n              </b>\n              .\n            </p>\n          </div>\n        </div>\n\n        <hr />\n\n        <div className=\"row\">\n          <div className=\"col-12\">\n            {/* \n              Sending a transaction isn't an immidiate action. You have to wait\n              for it to be mined.\n              If we are waiting for one, we show a message here.\n            */}\n            {this.state.txBeingSent && (\n              <WaitingForTransactionMessage txHash={this.state.txBeingSent} />\n            )}\n\n            {/* \n              Sending a transaction can fail in multiple ways. \n              If that happened, we show a message here.\n            */}\n            {this.state.transactionError && (\n              <TransactionErrorMessage\n                message={this._getRpcErrorMessage(this.state.transactionError)}\n                dismiss={() => this._dismissTransactionError()}\n              />\n            )}\n          </div>\n        </div>\n\n        <div className=\"row\">\n          <div className=\"col-12\">\n            {/*\n              If the user has no tokens, we don't show the Tranfer form\n            */}\n            {this.state.balance.eq(0) && (\n              <NoTokensMessage selectedAddress={this.state.selectedAddress} />\n            )}\n\n            {/*\n              This component displays a form that the user can use to send a \n              transaction and transfer some tokens.\n              The component doesn't have logic, it just calls the transferTokens\n              callback.\n            */}\n            {this.state.balance.gt(0) && (\n              <Transfer\n                transferTokens={(to, amount) =>\n                  this._transferTokens(to, amount)\n                }\n                tokenSymbol={this.state.tokenData.symbol}\n              />\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  componentWillUnmount() {\n    // We poll the user's balance, so we have to stop doing that when Dapp\n    // gets unmounted\n    this._stopPollingData();\n  }\n\n  async _connectWallet() {\n    // This method is run when the user clicks the Connect. It connects the\n    // dapp to the user's wallet, and initializes it.\n\n    // To connect to the user's wallet, we have to run this method.\n    // It returns a promise that will resolve to the user's address.\n    const [selectedAddress] = await window.ethereum.enable();\n\n    // Once we have the address, we can initialize the application.\n\n    // First we check the network\n    if (!this._checkNetwork()) {\n      return;\n    }\n\n    this._initialize(selectedAddress);\n\n    // We reinitialize it whenever the user changes their account.\n    window.ethereum.on(\"accountsChanged\", ([newAddress]) => {\n      this._stopPollingData();\n      // `accountsChanged` event can be triggered with an undefined newAddress.\n      // This happens when the user removes the Dapp from the \"Connected\n      // list of sites allowed access to your addresses\" (Metamask > Settings > Connections)\n      // To avoid errors, we reset the dapp state \n      if (newAddress === undefined) {\n        return this._resetState();\n      }\n      \n      this._initialize(newAddress);\n    });\n    \n    // We reset the dapp state if the network is changed\n    window.ethereum.on(\"networkChanged\", ([networkId]) => {\n      this._stopPollingData();\n      this._resetState();\n    });\n  }\n\n  _initialize(userAddress) {\n    // This method initializes the dapp\n\n    // We first store the user's address in the component's state\n    this.setState({\n      selectedAddress: userAddress,\n    });\n\n    // Then, we initialize ethers, fetch the token's data, and start polling\n    // for the user's balance.\n\n    // Fetching the token data and the user's balance are specific to this\n    // sample project, but you can reuse the same initialization pattern.\n    this._intializeEthers();\n    this._getTokenData();\n    this._startPollingData();\n  }\n\n  async _intializeEthers() {\n    // We first initialize ethers by creating a provider using window.ethereum\n    this._provider = new ethers.providers.Web3Provider(window.ethereum);\n\n    // When, we initialize the contract using that provider and the token's\n    // artifact. You can do this same thing with your contracts.\n    this._token = new ethers.Contract(\n      contractAddress.Token,\n      TokenArtifact.abi,\n      this._provider.getSigner(0)\n    );\n  }\n\n  // The next two methods are needed to start and stop polling data. While\n  // the data being polled here is specific to this example, you can use this\n  // pattern to read any data from your contracts.\n  //\n  // Note that if you don't need it to update in near real time, you probably\n  // don't need to poll it. If that's the case, you can just fetch it when you\n  // initialize the app, as we do with the token data.\n  _startPollingData() {\n    this._pollDataInterval = setInterval(() => this._updateBalance(), 1000);\n\n    // We run it once immediately so we don't have to wait for it\n    this._updateBalance();\n  }\n\n  _stopPollingData() {\n    clearInterval(this._pollDataInterval);\n    this._pollDataInterval = undefined;\n  }\n\n  // The next two methods just read from the contract and store the results\n  // in the component state.\n  async _getTokenData() {\n    const name = await this._token.name();\n    const symbol = await this._token.symbol();\n\n    this.setState({ tokenData: { name, symbol } });\n  }\n\n  async _updateBalance() {\n    const balance = await this._token.balanceOf(this.state.selectedAddress);\n    this.setState({ balance });\n  }\n\n  // This method sends an ethereum transaction to transfer tokens.\n  // While this action is specific to this application, it illustrates how to\n  // send a transaction.\n  async _transferTokens(to, amount) {\n    // Sending a transaction is a complex operation:\n    //   - The user can reject it\n    //   - It can fail before reaching the ethereum network (i.e. if the user\n    //     doesn't have ETH for paying for the tx's gas)\n    //   - It has to be mined, so it isn't immediately confirmed.\n    //     Note that some testing networks, like Hardhat Network, do mine\n    //     transactions immediately, but your dapp should be prepared for\n    //     other networks.\n    //   - It can fail once mined.\n    //\n    // This method handles all of those things, so keep reading to learn how to\n    // do it.\n\n    try {\n      // If a transaction fails, we save that error in the component's state.\n      // We only save one such error, so before sending a second transaction, we\n      // clear it.\n      this._dismissTransactionError();\n\n      // We send the transaction, and save its hash in the Dapp's state. This\n      // way we can indicate that we are waiting for it to be mined.\n      const tx = await this._token.transfer(to, amount);\n      this.setState({ txBeingSent: tx.hash });\n\n      // We use .wait() to wait for the transaction to be mined. This method\n      // returns the transaction's receipt.\n      const receipt = await tx.wait();\n\n      // The receipt, contains a status flag, which is 0 to indicate an error.\n      if (receipt.status === 0) {\n        // We can't know the exact error that made the transaction fail when it\n        // was mined, so we throw this generic one.\n        throw new Error(\"Transaction failed\");\n      }\n\n      // If we got here, the transaction was successful, so you may want to\n      // update your state. Here, we update the user's balance.\n      await this._updateBalance();\n    } catch (error) {\n      // We check the error code to see if this error was produced because the\n      // user rejected a tx. If that's the case, we do nothing.\n      if (error.code === ERROR_CODE_TX_REJECTED_BY_USER) {\n        return;\n      }\n\n      // Other errors are logged and stored in the Dapp's state. This is used to\n      // show them to the user, and for debugging.\n      console.error(error);\n      this.setState({ transactionError: error });\n    } finally {\n      // If we leave the try/catch, we aren't sending a tx anymore, so we clear\n      // this part of the state.\n      this.setState({ txBeingSent: undefined });\n    }\n  }\n\n  // This method just clears part of the state.\n  _dismissTransactionError() {\n    this.setState({ transactionError: undefined });\n  }\n\n  // This method just clears part of the state.\n  _dismissNetworkError() {\n    this.setState({ networkError: undefined });\n  }\n\n  // This is an utility method that turns an RPC error into a human readable\n  // message.\n  _getRpcErrorMessage(error) {\n    if (error.data) {\n      return error.data.message;\n    }\n\n    return error.message;\n  }\n\n  // This method resets the state\n  _resetState() {\n    this.setState(this.initialState);\n  }\n\n  // This method checks if Metamask selected network is Localhost:8545 \n  _checkNetwork() {\n    if (window.ethereum.networkVersion === HARDHAT_NETWORK_ID) {\n      return true;\n    }\n\n    this.setState({ \n      networkError: 'Please connect Metamask to Localhost:8545'\n    });\n\n    return false;\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Dapp } from \"./components/Dapp\";\n\n// We import bootstrap here, but you can remove if you want\nimport \"bootstrap/dist/css/bootstrap.css\";\n\n// This is the entry point of your application, but it just renders the Dapp\n// react component. All of the logic is contained in it.\n\nReactDOM.render(\n  <React.StrictMode>\n    <Dapp />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}